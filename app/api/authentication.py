"""
Provides authentication functions and processes. An authentication token can be generated by calling this script. The
token can then be sent in with requests as an "Authorization" header with a value of "Bearer <token>", where <token> is
the token that was generated.
"""

import os

from flask import current_app, request
from flask_httpauth import HTTPTokenAuth
from itsdangerous import Serializer, BadSignature

from app import create_app
from app.api import api
from app.api.errors import forbidden, unauthorized
from configuration import DEVELOPMENT_KEY, ENV_FLASK_CONFIGURATION

auth = HTTPTokenAuth()


@auth.error_handler
def auth_error():
    return unauthorized('Invalid credentials')


@api.before_request
@auth.login_required
def before_request():
    if request.method == 'OPTIONS':
        # Disclude OPTIONS requests from authorization as it is just the browser seeing what headers, etc. can be sent
        #  and does not allow authorization to be completed as the authorization header is not allowed by default, so
        #  nothing to authorize with
        return
    if not auth.current_user():
        return forbidden('Invalid user')


class Authenticator:
    __serializer: Serializer

    def __init__(self):
        try:
            app = current_app
            app.app_context()
        except RuntimeError:
            app = create_app(os.getenv(ENV_FLASK_CONFIGURATION) or DEVELOPMENT_KEY)

        with app.app_context():
            self.__serializer = Serializer(current_app.config['SECRET_KEY'])

    def generate_token(self, name: str):
        """
        Generates an authentication token. This protects against unauthorized users from accessing resources, however,
        can be intercepted if not using https and then re-used, so is only basic protection without SSL. It is intended
        to be used manually for generating tokens for trusted users.
        """

        return self.__serializer.dumps(name)

    def verify_token(self, token: str):
        try:
            return self.__serializer.loads(token)
        except BadSignature:
            return False


@auth.verify_token
def verify_token(token):
    return Authenticator().verify_token(token)


if __name__ == '__main__':
    value = input('Name: ')
    print(Authenticator().generate_token(value))
