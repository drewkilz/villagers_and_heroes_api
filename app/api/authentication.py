"""
Provides authentication functions and processes. An authentication token can be generated by calling this script with
the name of the user as the argument. The token can then be sent in with requests as an "Authorization" header with a
value of "Bearer <token>", where <token> is the token that was generated.

Currently, no tokens have been generated as the only desired user of the api is this application, which calls the api
internally, so does not need a token. If the api was moved to it's own application instance, a token would need to be
introduced.
"""

import sys

from flask import current_app, request
from flask_httpauth import HTTPTokenAuth
from itsdangerous import Serializer, BadSignature

from app.api import api
from app.api.errors import forbidden, unauthorized

auth = HTTPTokenAuth()


@auth.error_handler
def auth_error():
    return unauthorized('Invalid credentials')


@api.before_request
@auth.login_required
def before_request():
    if request.method == 'OPTIONS':
        # Disclude OPTIONS requests from authorization as it is just the browser seeing what headers, etc. can be sent
        #  and does not allow authorization to be completed as the authorization header is not allowed by default, so
        #  nothing to authorize with
        return
    if not auth.current_user():
        return forbidden('Invalid user')


class Authenticator:
    __serializer: Serializer

    def __init__(self):
        self.__serializer = Serializer(current_app.config['SECRET_KEY'])

    def generate_token(self, name: str):
        """
        Generates an authentication token. This protects against unauthorized users from accessing resources, however,
        can be intercepted if not using https and then re-used, so is only basic protection without SSL. It is intended
        to be used manually for generating tokens for trusted users.
        """

        return self.__serializer.dumps(name)

    def verify_token(self, token: str):
        try:
            return self.__serializer.loads(token)
        except BadSignature:
            return False


@auth.verify_token
def verify_token(token):
    return Authenticator().verify_token(token)


if __name__ == '__main__':
    print(Authenticator().generate_token(sys.argv[0]))
